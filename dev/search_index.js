var documenterSearchIndex = {"docs":
[{"location":"comparison/#Comparison","page":"Comparison","title":"Comparison","text":"Detangle is best when you want explicit, inspectable task dependencies from effect and region annotations.","category":"section"},{"location":"comparison/#Quick-fit-check","page":"Comparison","title":"Quick fit check","text":"Detangle is usually a strong fit when:\n\nyou have shared-memory workloads,\nwork is naturally task-graph shaped,\nand you want dependency logic to be explicit in code.\n\nIt is usually not the first tool to reach for when:\n\na single Threads.@threads loop already models the whole workload,\nthe workload is primarily distributed across machines,\nor dependency structure is trivial and static.","category":"section"},{"location":"comparison/#Detangle-vs-Threads.@threads","page":"Comparison","title":"Detangle vs Threads.@threads","text":"Threads.@threads is great for regular data-parallel loops. Detangle is a better fit when:\n\nWork is naturally a graph, not one loop.\nDifferent tasks touch different objects/regions.\nYou want dependency reasoning to stay explicit in code.","category":"section"},{"location":"comparison/#Detangle-vs-manual-Threads.@spawn","page":"Comparison","title":"Detangle vs manual Threads.@spawn","text":"Manual @spawn gives full control but dependency management is on you. Detangle adds:\n\nDeclarative read/write/reduce access metadata\nAutomatic DAG edge construction from conflicts\nDiagnostics (print_dag, explain_conflict)","category":"section"},{"location":"comparison/#Detangle-vs-ad-hoc-locks/atomics","page":"Comparison","title":"Detangle vs ad-hoc locks/atomics","text":"Locks and atomics can solve contention but usually make intent harder to read. Detangle shifts correctness to task declarations:\n\nSafer default ordering from conflict analysis\nOptional reduction privatization for Reduce(op) patterns","category":"section"},{"location":"comparison/#Detangle-vs-distributed-schedulers","page":"Comparison","title":"Detangle vs distributed schedulers","text":"For single-process shared-memory workloads, Detangle keeps overhead low and APIs simple. If you need cluster/distributed execution, specialized distributed runtimes are a better match.","category":"section"},{"location":"comparison/#Rule-of-thumb","page":"Comparison","title":"Rule of thumb","text":"Choose Detangle when you want:\n\nShared-memory parallelism\nExplicit, auditable dependency structure\nA path from serial correctness to threaded execution with minimal code changes","category":"section"},{"location":"tutorials/overview/#Tutorials-Overview","page":"Overview","title":"Tutorials Overview","text":"Tutorial pages are generated from numbered scripts in examples/ (for example, 01_basic_dag.jl) and added to the docs navigation automatically.","category":"section"},{"location":"tutorials/overview/#How-tutorial-generation-works","page":"Overview","title":"How tutorial generation works","text":"Source code is rendered directly from each example script.\nMost tutorials are rendered-only (the script is not executed during docs build).\nSome tutorials include generated output sections:\nMolecular dynamics: animation generated from existing frame CSVs in examples/output/\nHistogram: real terminal output captured from running examples/04_histogram.jl","category":"section"},{"location":"tutorials/overview/#1.-Basic-DAG-construction","page":"Overview","title":"1. Basic DAG construction","text":"File: examples/01_basic_dag.jl\n\nWhat it covers:\n\nBuilding a small DAG with @dag, @spawn, @task\nAnnotating accesses with @accesses\nRunning with execute_serial! and execute_threads!\n\nRun:\n\njulia --project=. examples/01_basic_dag.jl","category":"section"},{"location":"tutorials/overview/#2.-Blocked-map/reduce-style-workload","page":"Overview","title":"2. Blocked map/reduce-style workload","text":"File: examples/02_block_sum.jl\n\nWhat it covers:\n\nSplitting work via eachblock\nCreating one task per block with detangle_foreach\nComparing threaded DAG execution to a serial baseline\n\nRun:\n\nJULIA_NUM_THREADS=8 julia --project=. examples/02_block_sum.jl","category":"section"},{"location":"tutorials/overview/#3.-Molecular-dynamics-style-pipeline","page":"Overview","title":"3. Molecular dynamics style pipeline","text":"File: examples/03_molecular_dynamics.jl\n\nWhat it covers:\n\nMulti-stage per-block pipelines\nWhole-array reads plus block-local writes\nReusing a DAG across many simulation steps\n\nRun:\n\nJULIA_NUM_THREADS=8 julia --project=. examples/03_molecular_dynamics.jl","category":"section"},{"location":"tutorials/overview/#4.-Parallel-histogram-with-reduction-privatization","page":"Overview","title":"4. Parallel histogram with reduction privatization","text":"File: examples/04_histogram.jl\n\nWhat it covers:\n\nReduce(+) access declarations\nreduce_add! for reduction updates\nexecute!(...; reduce_strategy=:privatize)\n\nRun:\n\nJULIA_NUM_THREADS=8 julia --project=. examples/04_histogram.jl","category":"section"},{"location":"manual/api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"This page is organized by concept rather than one flat symbol list.","category":"section"},{"location":"manual/api_reference/#Effects","page":"API Reference","title":"Effects","text":"","category":"section"},{"location":"manual/api_reference/#Regions","page":"API Reference","title":"Regions","text":"","category":"section"},{"location":"manual/api_reference/#Access-And-Tasks","page":"API Reference","title":"Access And Tasks","text":"","category":"section"},{"location":"manual/api_reference/#Conflicts-And-DAG-Construction","page":"API Reference","title":"Conflicts And DAG Construction","text":"","category":"section"},{"location":"manual/api_reference/#Execution","page":"API Reference","title":"Execution","text":"","category":"section"},{"location":"manual/api_reference/#Macros","page":"API Reference","title":"Macros","text":"","category":"section"},{"location":"manual/api_reference/#Convenience-Builders","page":"API Reference","title":"Convenience Builders","text":"","category":"section"},{"location":"manual/api_reference/#Diagnostics","page":"API Reference","title":"Diagnostics","text":"","category":"section"},{"location":"manual/api_reference/#Detangle.Effect","page":"API Reference","title":"Detangle.Effect","text":"Effect\n\nAbstract supertype for task access effects.\n\nEffects describe how a task interacts with a region of an object and are used to derive dependency edges in the DAG.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.Read","page":"API Reference","title":"Detangle.Read","text":"Read() <: Effect\nWrite() <: Effect\nReadWrite() <: Effect\n\nEffect markers used in access declarations.\n\nRead() means the task only reads a region.\nWrite() means the task overwrites or mutates a region.\nReadWrite() means the task both reads and mutates a region.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.Reduce","page":"API Reference","title":"Detangle.Reduce","text":"Reduce(op) <: Effect\n\nReduction effect carrying the operator op.\n\nArguments\n\nop: Associative reduction operator, commonly + or *.\n\nNotes\n\nParallel reduction behavior depends on execution strategy.\nWhen using privatized reduction execution, task bodies should update through reduce_add!.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.is_reduce-Tuple{Reduce}","page":"API Reference","title":"Detangle.is_reduce","text":"is_reduce(eff::Effect) -> Bool\n\nPredicate that returns true only for Reduce(...) effects.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.is_writeish-Tuple{Read}","page":"API Reference","title":"Detangle.is_writeish","text":"is_writeish(eff::Effect) -> Bool\n\nReturn whether eff should be treated as mutating for conflict analysis.\n\nReturns\n\nfalse for Read()\ntrue for Write(), ReadWrite(), and Reduce(...)\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.reduce_op-Tuple{Reduce}","page":"API Reference","title":"Detangle.reduce_op","text":"reduce_op(r::Reduce)\n\nReturn the reduction operator stored in r.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.Block","page":"API Reference","title":"Detangle.Block","text":"Block(r::UnitRange{Int}) <: Region\n\nOne-dimensional contiguous index range.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.IndexSet","page":"API Reference","title":"Detangle.IndexSet","text":"IndexSet(idxs::AbstractVector{Int}) <: Region\n\nSparse set of explicit indices.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.Key","page":"API Reference","title":"Detangle.Key","text":"Key(k) <: Region\n\nRegion representing a single logical key k, typically used for map-like containers or keyed partitions.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.Region","page":"API Reference","title":"Detangle.Region","text":"Region\n\nAbstract supertype for region descriptors used by access declarations.\n\nA region scopes an effect to a subset of an object so Detangle can distinguish independent accesses from conflicting ones.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.Tile","page":"API Reference","title":"Detangle.Tile","text":"Tile(I::UnitRange{Int}, J::UnitRange{Int}) <: Region\n\nTwo-dimensional rectangular tile defined by row range I and column range J.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.Whole","page":"API Reference","title":"Detangle.Whole","text":"Whole() <: Region\n\nRegion representing an entire object.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.overlaps-Tuple{IndexSet, IndexSet}","page":"API Reference","title":"Detangle.overlaps","text":"overlaps(a::IndexSet, b::IndexSet) -> Bool\n\nConservative overlap check for sparse index sets.\n\nCurrently returns true to avoid missed dependencies.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.overlaps-Tuple{Whole, Whole}","page":"API Reference","title":"Detangle.overlaps","text":"overlaps(a::Region, b::Region) -> Bool\n\nReturn whether regions a and b may overlap.\n\nSemantics\n\nWhole() overlaps everything.\nKey(k1) overlaps Key(k2) only when k1 == k2.\nBlock and Tile use range intersection checks.\nIndexSet currently uses a conservative overlap policy for IndexSet pairs.\nUnknown region combinations default to conservative true.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.ranges_overlap-Tuple{UnitRange{Int64}, UnitRange{Int64}}","page":"API Reference","title":"Detangle.ranges_overlap","text":"ranges_overlap(a::UnitRange{Int}, b::UnitRange{Int}) -> Bool\n\nReturn true when integer ranges a and b intersect.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.Access","page":"API Reference","title":"Detangle.Access","text":"Access\n\nAccess metadata used for dependency analysis.\n\nFields\n\nobjid::UInt64: Stable object identity (objectid(obj)).\nobj::Any: Original object reference (kept for diagnostics).\neff::Effect: Access effect (Read, Write, ReadWrite, Reduce).\nreg::Region: Region descriptor over the object.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.access-Tuple{Any, Detangle.Effect, Detangle.Region}","page":"API Reference","title":"Detangle.access","text":"access(obj, eff::Effect, reg::Region) -> Access\n\nConstruct an Access record from an object, effect, and region.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.objkey-Tuple{Any}","page":"API Reference","title":"Detangle.objkey","text":"objkey(obj) -> (UInt64, Any)\n\nReturn (objectid(obj), obj) for reuse in access construction and debugging.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.TaskSpec","page":"API Reference","title":"Detangle.TaskSpec","text":"TaskSpec\n\nExecutable task plus declarative access metadata.\n\nFields\n\nname::String: Human-readable task label.\naccesses::Vector{Access}: Access declarations used for dependency analysis.\nthunk::Function: Zero-argument function containing task work.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.TaskSpec-Tuple{String, Function}","page":"API Reference","title":"Detangle.TaskSpec","text":"TaskSpec(name::String, thunk::Function) -> TaskSpec\n\nConstruct a task with an empty access list.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.add_access!-Tuple{TaskSpec, Any, Detangle.Effect, Detangle.Region}","page":"API Reference","title":"Detangle.add_access!","text":"add_access!(task::TaskSpec, obj, eff::Effect, reg::Region) -> TaskSpec\n\nAppend one access declaration to task and return the same task.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.conflicts-Tuple{Access, Access}","page":"API Reference","title":"Detangle.conflicts","text":"conflicts(a::Access, b::Access; can_parallel_reduce::Bool=false) -> Bool\n\nReturn whether two accesses require an ordering dependency.\n\nArguments\n\na, b: Access declarations to compare.\ncan_parallel_reduce: If true, allows Reduce(op) pairs with identical op to proceed in parallel.\n\nRules\n\nDifferent objects never conflict.\nNon-overlapping regions never conflict.\nAny write-like effect conflicts, except optional compatible reductions.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.task_conflicts-Tuple{TaskSpec, TaskSpec}","page":"API Reference","title":"Detangle.task_conflicts","text":"task_conflicts(ti::TaskSpec, tj::TaskSpec; can_parallel_reduce::Bool=false) -> Bool\n\nReturn true if any access pair across ti and tj conflicts.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.DAG","page":"API Reference","title":"Detangle.DAG","text":"DAG\n\nDependency graph over TaskSpec nodes.\n\nFields\n\ntasks::Vector{TaskSpec}: Tasks in insertion order.\nedges::Vector{Vector{Int}}: Adjacency list (i -> successors).\nindeg::Vector{Int}: Indegree count for each task.\n\nNotes\n\nA newly created DAG() contains tasks only after push!.\nCall finalize! to construct edges and indeg.\n\n\n\n\n\n","category":"type"},{"location":"manual/api_reference/#Detangle.DAG-Tuple{}","page":"API Reference","title":"Detangle.DAG","text":"DAG() -> DAG\n\nCreate an empty DAG builder with no tasks and no computed edges.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Base.push!-Tuple{DAG, TaskSpec}","page":"API Reference","title":"Base.push!","text":"push!(dag::DAG, task::TaskSpec) -> DAG\n\nAppend task to dag and return the same DAG.\n\nNotes\n\nThis does not recompute dependencies. Call finalize! after appending tasks.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.finalize!-Tuple{DAG}","page":"API Reference","title":"Detangle.finalize!","text":"finalize!(dag::DAG; can_parallel_reduce::Bool=false) -> DAG\n\nBuild dependency edges and indegrees for dag using pairwise task conflict checks while preserving insertion order.\n\nArguments\n\ncan_parallel_reduce: If true, compatible Reduce(op) tasks may execute concurrently.\n\nComplexity\n\nO(T^2) over number of tasks.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.execute!-Tuple{DAG}","page":"API Reference","title":"Detangle.execute!","text":"execute!(\n    dag::DAG;\n    backend=:threads,\n    nworkers::Integer=Threads.nthreads(),\n    reduce_strategy=:serialize,\n) -> DAG\n\nExecute a finalized DAG with the selected backend and reduction strategy.\n\nArguments\n\nbackend: :threads or :serial.\nnworkers: Number of worker tasks when backend=:threads.\nreduce_strategy: :serialize (default) or :privatize.\n\nReturns\n\nThe executed dag.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.execute_serial!-Tuple{DAG}","page":"API Reference","title":"Detangle.execute_serial!","text":"execute_serial!(dag::DAG) -> DAG\n\nExecute dag in topological order on the current thread.\n\nUseful for debugging and correctness baselines.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.execute_threads!-Tuple{DAG}","page":"API Reference","title":"Detangle.execute_threads!","text":"execute_threads!(dag::DAG; nworkers::Integer=Threads.nthreads()) -> DAG\n\nExecute dag using Julia threads with a ready-queue scheduler.\n\nArguments\n\nnworkers: Number of worker tasks spawned to process ready nodes.\n\nNotes\n\nAssumes dag has valid edges/indeg from finalize!.\nRethrows the first task error after workers complete.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.ReducerKey-Tuple{Any, Any, Any}","page":"API Reference","title":"Detangle.ReducerKey","text":"ReducerKey(objid, reg, op)\n\nInternal key identifying a reduction target by object identity, region, and operator.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle._reduce_identity-Union{Tuple{T}, Tuple{Function, Type{T}}} where T","page":"API Reference","title":"Detangle._reduce_identity","text":"_reduce_identity(op::Function, ::Type{T}) where {T}\n\nInternal helper that returns identity elements for supported operators.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.alloc_reducers-Tuple{DAG}","page":"API Reference","title":"Detangle.alloc_reducers","text":"alloc_reducers(dag::DAG; nthreads::Integer=Threads.maxthreadid()) -> ReduceContext\n\nAllocate per-thread reduction buffers for all Reduce(...) accesses in dag.\n\nSupported targets\n\nAbstractVector with regions Whole() and Block(...).\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.combine!-Tuple{Detangle.ReduceContext}","page":"API Reference","title":"Detangle.combine!","text":"combine!(ctx::ReduceContext)\n\nInternal helper that folds thread-local reduction buffers into destination objects.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.execute_privatize!-Tuple{DAG}","page":"API Reference","title":"Detangle.execute_privatize!","text":"execute_privatize!(\n    dag::DAG;\n    backend=:threads,\n    nworkers::Integer=Threads.nthreads(),\n) -> DAG\n\nExecute dag with reduction privatization enabled.\n\nArguments\n\nbackend: :threads or :serial.\nnworkers: Worker count for threaded backend.\n\nBehavior\n\nRe-finalizes with can_parallel_reduce=true.\nAllocates reducer buffers for declared Reduce accesses.\nExecutes the DAG.\nCombines per-thread buffers into real reduction targets.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.reduce_add!-Tuple{AbstractVector, Function, Detangle.Region, Int64, Any}","page":"API Reference","title":"Detangle.reduce_add!","text":"reduce_add!(\n    obj::AbstractVector,\n    op::Function,\n    reg::Region,\n    idx::Int,\n    value,\n) -> AbstractVector\n\nAccumulate value into obj[idx] using reduction operator op.\n\nArguments\n\nobj: Destination vector being reduced into.\nop: Reduction operator (for example +).\nreg: Declared reduction region (Whole() or Block(...)).\nidx: Global index in obj to update.\nvalue: Contribution to combine at idx.\n\nBehavior\n\nIn normal execution, updates obj directly.\nIn privatized execution, updates a thread-local reduction buffer.\n\nNotes\n\nreg and op must match a declared Reduce(op) access for the task.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.@access-Tuple{Any, Any, Any}","page":"API Reference","title":"Detangle.@access","text":"@access obj eff reg\n\nDeclare one access inside a @task body.\n\nArguments\n\nobj: Object being accessed.\neff: Effect instance (Read(), Write(), ReadWrite(), Reduce(op)).\nreg: Region instance (Whole(), Block(...), Key(...), ...).\n\nNotes\n\nValid only inside @task.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api_reference/#Detangle.@accesses-Tuple{Any}","page":"API Reference","title":"Detangle.@accesses","text":"@accesses begin\n    (obj1, eff1, reg1)\n    (obj2, eff2, reg2)\n    ...\nend\n\nDeclare multiple accesses inside a @task body.\n\nEach entry must be a 3-tuple (obj, eff, reg).\n\n\n\n\n\n","category":"macro"},{"location":"manual/api_reference/#Detangle.@dag-Tuple{Any}","page":"API Reference","title":"Detangle.@dag","text":"@dag begin\n    ...\nend\n\nCreate a DAG builder context, collect tasks appended via @spawn, and return a finalized DAG.\n\nExample\n\ndag = Detangle.@dag begin\n    Detangle.@spawn Detangle.@task \"t1\" begin\n        ...\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"manual/api_reference/#Detangle.@spawn-Tuple{Any}","page":"API Reference","title":"Detangle.@spawn","text":"@spawn expr\n\nAppend task expression expr to the current @dag builder.\n\nNotes\n\nexpr should evaluate to a TaskSpec (or compatible value accepted by push! on DAG).\nValid only within @dag.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api_reference/#Detangle.@task-Tuple{Any, Any}","page":"API Reference","title":"Detangle.@task","text":"@task name begin\n    ...\nend\n\nCreate a TaskSpec from a task body.\n\nBehavior\n\nCollects @access obj eff reg and @accesses begin ... end declarations into TaskSpec.accesses.\nRemoves those access declarations from the runtime thunk so they are metadata only.\nStores remaining statements as the task's zero-argument thunk.\n\nArguments\n\nname: Task name expression that must evaluate to a String.\nbegin ... end: Task body containing access declarations and work.\n\nExample\n\nDetangle.@task \"scale\" begin\n    Detangle.@access x Read() Whole()\n    Detangle.@access y Write() Whole()\n    y .= 2 .* x\nend\n\n\n\n\n\n","category":"macro"},{"location":"manual/api_reference/#Detangle.detangle_foreach!-Tuple{DAG, Any, Function}","page":"API Reference","title":"Detangle.detangle_foreach!","text":"detangle_foreach!(dag::DAG, blocks, task_builder::Function) -> DAG\n\nAppend tasks produced by task_builder(r, i) directly to an existing DAG.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.detangle_foreach!-Tuple{DAG, Function, Any}","page":"API Reference","title":"Detangle.detangle_foreach!","text":"detangle_foreach!(dag::DAG, task_builder::Function, blocks) -> DAG\n\nDo-block friendly overload for detangle_foreach!.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.detangle_foreach-Tuple{Any, Function}","page":"API Reference","title":"Detangle.detangle_foreach","text":"detangle_foreach(blocks, task_builder::Function; finalize::Bool=true) -> DAG\n\nBuild a DAG by applying task_builder(r, i) to each block.\n\nArguments\n\nblocks: Block collection (commonly ranges from eachblock).\ntask_builder: Function returning a TaskSpec or collection of TaskSpec.\nfinalize: If true, calls finalize! before returning.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.detangle_foreach-Tuple{Function, Any}","page":"API Reference","title":"Detangle.detangle_foreach","text":"detangle_foreach(task_builder::Function, blocks; finalize::Bool=true) -> DAG\n\nDo-block friendly overload:\n\ndetangle_foreach(blocks) do r, i\n    ...\nend\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.detangle_map!-Tuple{AbstractVector, AbstractVector, Any, Function}","page":"API Reference","title":"Detangle.detangle_map!","text":"detangle_map!(\n    dest::AbstractVector,\n    data::AbstractVector,\n    blocks,\n    f::Function;\n    finalize::Bool=true,\n    name_prefix::String=\"map\",\n) -> DAG\n\nCreate block tasks that apply f elementwise to data and write into dest.\n\nArguments\n\ndest, data: Equal-length vectors.\nblocks: Index ranges defining task partitions.\nf: Elementwise transform.\nfinalize: Whether to finalize the returned DAG.\nname_prefix: Task name prefix.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.detangle_map-Tuple{AbstractVector, Any, Function}","page":"API Reference","title":"Detangle.detangle_map","text":"detangle_map(\n    data::AbstractVector,\n    blocks,\n    f::Function;\n    finalize::Bool=true,\n    name_prefix::String=\"map\",\n) -> Tuple{DAG, AbstractVector}\n\nAllocate an output vector, build a block map DAG, and return (dag, dest).\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.detangle_mapreduce","page":"API Reference","title":"Detangle.detangle_mapreduce","text":"detangle_mapreduce(\n    data::AbstractVector,\n    blocks,\n    op::Function,\n    mapf::Function=identity;\n    finalize::Bool=true,\n    name_prefix::String=\"mapreduce\",\n) -> Tuple{DAG, Vector}\n\nBuild a block map-reduce DAG over data.\n\nArguments\n\ndata: Input vector.\nblocks: Index ranges for per-task work.\nop: Reduction operator used by Reduce(op) and reduce_add!.\nmapf: Per-element transform before reduction.\nfinalize: Whether to finalize the returned DAG.\nname_prefix: Task name prefix.\n\nReturns\n\n(dag, acc) where acc is a length-1 vector storing the reduced value.\n\n\n\n\n\n","category":"function"},{"location":"manual/api_reference/#Detangle.eachblock-Tuple{AbstractArray, Integer}","page":"API Reference","title":"Detangle.eachblock","text":"eachblock(data::AbstractArray, block_size::Integer) -> Vector{UnitRange{Int}}\n\nConvenience overload equivalent to eachblock(length(data), block_size).\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.eachblock-Tuple{Integer, Integer}","page":"API Reference","title":"Detangle.eachblock","text":"eachblock(n::Integer, block_size::Integer) -> Vector{UnitRange{Int}}\n\nSplit 1:n into contiguous blocks of size block_size (last block may be shorter).\n\nArguments\n\nn: Number of logical elements.\nblock_size: Positive block size.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.task_from_accesses-Tuple{String, AbstractVector, Function}","page":"API Reference","title":"Detangle.task_from_accesses","text":"task_from_accesses(\n    name::String,\n    accesses::AbstractVector,\n    thunk::Function,\n) -> TaskSpec\n\nBuild a TaskSpec from a list of access tuples and a zero-arg thunk.\n\nArguments\n\nname: Task name.\naccesses: Iterable of (obj, eff, reg) tuples.\nthunk: Task body.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Base.show-Tuple{IO, Access}","page":"API Reference","title":"Base.show","text":"show(io::IO, a::Access)\n\nRender an Access as a compact single-line summary:\n\nEffect object#id region\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Base.show-Tuple{IO, TaskSpec}","page":"API Reference","title":"Base.show","text":"show(io::IO, t::TaskSpec)\n\nRender a TaskSpec with name and condensed access list.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.explain_conflict-Tuple{TaskSpec, TaskSpec}","page":"API Reference","title":"Detangle.explain_conflict","text":"explain_conflict(\n    ti::TaskSpec,\n    tj::TaskSpec;\n    can_parallel_reduce::Bool=false,\n) -> Union{Nothing, Tuple{Access,Access}}\n\nReturn the first conflicting access pair between ti and tj, or nothing when no conflict is found.\n\n\n\n\n\n","category":"method"},{"location":"manual/api_reference/#Detangle.print_dag-Tuple{DAG}","page":"API Reference","title":"Detangle.print_dag","text":"print_dag(dag::DAG; io::IO=stdout)\n\nPrint adjacency and levelized structure for a finalized DAG.\n\nNotes\n\nIf dag is not finalized, prints a message and returns.\nAlso warns when remaining indegrees suggest a cycle.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/generated/02_block_sum/#Block-Sum","page":"Block Sum","title":"Block Sum","text":"This page is auto-generated from examples/02_block_sum.jl.\n\nThe tutorial code is rendered only (not executed during docs build).\n\nusing Detangle\n\n# Example: block a vector into ranges, spawn one task per block, and write each\n# block's sum into its own slot. This makes the parallel reduction safe and lets\n# us compare against a serial loop with similar work.\nn = 5_000_000\nblock_size = 250_000\ndata = collect(1:n)\n\n# Work kernel used by both the DAG and the serial baseline.\nfunction block_sum(data, r)\n    acc = 0\n    for idx in r\n        v = data[idx]\n        acc += v * v - v\n    end\n    acc\nend\n\nfunction serial_total(data, blocks)\n    acc = 0\n    for r in blocks\n        acc += block_sum(data, r)\n    end\n    acc\nend\n\n# Precompute block ranges so each task declares a non-overlapping region.\nblocks = eachblock(n, block_size)\npartials = zeros(Int, length(blocks))\n\ndag = detangle_foreach(blocks) do r, bi\n    # Each task reads its block and writes one slot in the partials array.\n    Detangle.@task \"block-$bi\" begin\n        Detangle.@access data Read() Block(r)\n        Detangle.@access partials Write() Key(bi)\n        partials[bi] = block_sum(data, r)\n    end\nend\n\n# Warm up JIT compilation so timing reflects execution cost, not compilation.\nexecute_threads!(dag)\nsum(partials)\nblock_sum(data, blocks[1])\n\n# Time the DAG run (parallel if you use execute_threads! and JULIA_NUM_THREADS>1).\n# Run with e.g. `JULIA_NUM_THREADS=8` to see parallel speedups.\nt_dag = @elapsed begin\n    execute_threads!(dag)\n    sum(partials)\nend\n\n# Time a plain serial baseline using the same work kernel.\ntotal_plain = Ref(0)\nt_plain = @elapsed begin\n    total_plain[] = serial_total(data, blocks)\nend\n\nprintln(\"dag total = \", sum(partials), \" (\", t_dag, \"s)\")\nprintln(\"plain total = \", total_plain[], \" (\", t_plain, \"s)\")\n","category":"section"},{"location":"tutorials/generated/01_basic_dag/#Basic-Dag","page":"Basic Dag","title":"Basic Dag","text":"This page is auto-generated from examples/01_basic_dag.jl.\n\nThe tutorial code is rendered only (not executed during docs build).\n\nusing Detangle\n\nobj = Ref(0)\n\n# A simple three-task chain over the same object.\ndag = Detangle.@dag begin\n    # First task writes a fresh value.\n    Detangle.@spawn Detangle.@task \"init\" begin\n        Detangle.@accesses begin\n            (obj, Write(), Whole())\n        end\n        obj[] = 1\n    end\n\n    # Second task mutates the same object.\n    Detangle.@spawn Detangle.@task \"bump\" begin\n        Detangle.@accesses begin\n            (obj, ReadWrite(), Whole())\n        end\n        obj[] += 1\n    end\n\n    # Final task reads the result.\n    Detangle.@spawn Detangle.@task \"read\" begin\n        Detangle.@accesses begin\n            (obj, Read(), Whole())\n        end\n        println(\"value = \", obj[])\n    end\nend\n\n# Print the dependency structure, then run in a deterministic order.\nprint_dag(dag);\nexecute_serial!(dag); \nexecute_threads!(dag);  # Can also run with threads\n","category":"section"},{"location":"manual/overview/#Manual-Overview","page":"Overview","title":"Manual Overview","text":"This manual is split into three layers:\n\nOverview (this page): mental model plus one runnable example.\nConcepts and Semantics: detailed rules for effects, regions, and conflict detection.\nAPI Reference: generated docs for all exported types, functions, and macros.\n\nIf you are new to Detangle, start here, run the example, then continue to the Concepts page.","category":"section"},{"location":"manual/overview/#Who-this-manual-is-for","page":"Overview","title":"Who this manual is for","text":"This manual assumes you are comfortable with Julia and want to:\n\nexpress task-level parallel work,\nmake data dependencies explicit,\nand debug scheduling behavior with predictable rules.","category":"section"},{"location":"manual/overview/#The-mental-model","page":"Overview","title":"The mental model","text":"Detangle separates:\n\nTask code: the computation you want to run.\nAccess metadata: what each task reads/writes/reduces.\n\nFrom that metadata, Detangle builds a dependency DAG and executes it safely with either a serial or threaded backend.","category":"section"},{"location":"manual/overview/#A-complete-example","page":"Overview","title":"A complete example","text":"using Detangle\n\nx = rand(100)\ny = similar(x)\nblocks = eachblock(length(x), 25)\n\ndag = Detangle.@dag begin\n    for (i, r) in enumerate(blocks)\n        Detangle.@spawn Detangle.@task \"scale-$i\" begin\n            Detangle.@access x Read() Block(r)\n            Detangle.@access y Write() Block(r)\n            @inbounds for idx in r\n                y[idx] = 2 * x[idx]\n            end\n        end\n    end\nend\n\n# Optional: inspect the inferred dependency structure.\nprint_dag(dag)\n\n# Run serially first for correctness/debuggability.\nexecute_serial!(dag)\n\n# Then run threaded for parallel execution.\nexecute_threads!(dag)\n\nWhy these tasks can run in parallel:\n\nEvery task only reads from x.\nEvery task writes to a non-overlapping Block(r) of y.\n\nIf the writes overlapped, Detangle would introduce ordering edges automatically.","category":"section"},{"location":"manual/overview/#Where-to-go-next","page":"Overview","title":"Where to go next","text":"Concepts and Semantics\nAPI Reference","category":"section"},{"location":"tutorials/generated/03_molecular_dynamics/#Molecular-Dynamics","page":"Molecular Dynamics","title":"Molecular Dynamics","text":"This page is auto-generated from examples/03_molecular_dynamics.jl.\n\nThe tutorial code is rendered only (not executed during docs build).\n\nusing Detangle\n\ninclude(joinpath(@__DIR__, \"md_utils.jl\"))\n\nenvint(key, default) = parse(Int, get(ENV, key, string(default)))\nenvbool(key, default) = lowercase(get(ENV, key, default ? \"true\" : \"false\")) in (\"1\", \"true\", \"yes\", \"on\")\n\n# Simplified MD demo: per-block force/integration tasks with spatial binning.\n# Tasks declare which arrays/regions they read and write; Detangle uses that\n# information to order dependent work and expose safe parallelism.\n\n# === Parameters ===\n# n: number of particles.\n# box: side length of the square domain.\n# n_cells_x/n_cells_y: spatial bins for neighbor lookup (more cells => fewer particles per cell).\n# n_particles_per_thread: number of particles per task block (smaller => more tasks).\n# dt: timestep size for integration.\n# particle_radius: hard-sphere radius used for collision checks.\n# cutoff: interaction radius (set to 2x particle_radius).\n# k_spring: stiffness for the hard-sphere penalty force.\n# speed_mean/speed_std: mean and stddev of initial speed; direction is random.\n# steps: number of simulation steps to run.\n# save_frames: toggle writing CSV frames for animation.\n# frame_stride: save every Nth frame when save_frames=true.\n# progress_stride: print progress every N steps.\nn = 500\nbox = 10.0\nn_particles_per_thread = 10\ndt = 0.005\nparticle_radius = 0.2\ncutoff = 2 * particle_radius\nn_cells_x = n_cells_y = ceil(Int, box / cutoff)\nk_spring = -10.0\nspeed_mean = 1.0\nspeed_std = 0.2\nsteps = envint(\"DETANGLE_MD_STEPS\", 5000)\nsave_frames = envbool(\"DETANGLE_MD_SAVE_FRAMES\", true)\nframe_stride = envint(\"DETANGLE_MD_FRAME_STRIDE\", 10)\nprogress_stride = envint(\"DETANGLE_MD_PROGRESS_STRIDE\", 50)\noutput_dir = joinpath(@__DIR__, \"output\")\n\nprintln(\"initializing particles...\")\nposx, posy, velx, vely, forcex, forcey, blocks = init_particles_simple(\n    n,\n    box;\n    block_size=n_particles_per_thread,\n    speed_mean=speed_mean,\n    speed_std=speed_std,\n)\nblocks = particle_blocks(n, n_particles_per_thread)\ncutoff2 = cutoff * cutoff\nsoft = 1.0e-6\n# Spatial bins for neighbor lookup.\ncell_size = box / max(n_cells_x, n_cells_y)\nneighbor_radius = ceil(Int, cutoff / cell_size)\ncells = [Int[] for _ in 1:(n_cells_x * n_cells_y)]\ncell_of = zeros(Int, n)\nneighbors = [Int[] for _ in 1:(n_cells_x * n_cells_y)]\nbuild_neighbor_cells!(neighbors, n_cells_x, n_cells_y, neighbor_radius)\nbin_ctx = init_bin_context(n_cells_x * n_cells_y)\n\nfunction apply_bounce!(x, v, box)\n    # Reflect off walls to keep particles in-bounds.\n    if !isfinite(x) || !isfinite(v)\n        return x, v\n    end\n    while x < 0 || x > box\n        if x < 0\n            x = -x\n            v = -v\n        elseif x > box\n            x = 2 * box - x\n            v = -v\n        end\n    end\n    return x, v\nend\n\n# Compute hard-sphere penalty forces using spatial bins for neighbor lookup.\nfunction accumulate_forces!(r, cell_of, neighbors, cells, posx, posy, forcex, forcey, box, cutoff2, soft, particle_radius, k_spring)\n    for i in r\n        xi = posx[i]\n        yi = posy[i]\n        fx = 0.0\n        fy = 0.0\n        cid = cell_of[i]\n        for ncell in neighbors[cid]\n            for j in cells[ncell]\n                j == i && continue\n                dx = posx[j] - xi\n                dy = posy[j] - yi\n                if dx > box / 2\n                    dx -= box\n                elseif dx < -box / 2\n                    dx += box\n                end\n                if dy > box / 2\n                    dy -= box\n                elseif dy < -box / 2\n                    dy += box\n                end\n                r2 = dx * dx + dy * dy\n                if r2 < cutoff2\n                    r = sqrt(max(r2, 1.0e-6))\n                    overlap = 2 * particle_radius - r\n                    if overlap > 0\n                        f = k_spring * overlap / r\n                        fx += f * dx\n                        fy += f * dy\n                    end\n                end\n            end\n        end\n        forcex[i] = fx\n        forcey[i] = fy\n    end\nend\n\nfunction integrate_position!(r, posx, posy, velx, vely, forcex, forcey, dt, box)\n    # Velocity-Verlet position update (half-step velocity + full position).\n    for i in r\n        velx[i] += 0.5 * dt * forcex[i]\n        vely[i] += 0.5 * dt * forcey[i]\n        posx[i], velx[i] = apply_bounce!(posx[i] + dt * velx[i], velx[i], box)\n        posy[i], vely[i] = apply_bounce!(posy[i] + dt * vely[i], vely[i], box)\n    end\nend\n\nfunction integrate_velocity!(r, velx, vely, forcex, forcey, dt)\n    # Finish the velocity half-step after recomputing forces.\n    for i in r\n        velx[i] += 0.5 * dt * forcex[i]\n        vely[i] += 0.5 * dt * forcey[i]\n    end\nend\n\nprintln(\"building DAG...\")\n# The DAG is built once and reused each step. Each block contributes four tasks:\n#   1) forces-$bi: compute forces for particles in r using spatial bins.\n#   2) integrate-pos-$bi: advance positions with a half-step velocity update.\n#   3) forces2-$bi: recompute forces after positions update.\n#   4) integrate-vel-$bi: finish the velocity update.\n# Access annotations describe which regions are read or written so Detangle can\n# order dependent tasks and run independent blocks in parallel.\ndag = Detangle.@dag begin\n    Detangle.@spawn Detangle.@task \"bin-1\" begin\n        Detangle.@access posx Read() Whole()\n        Detangle.@access posy Read() Whole()\n        Detangle.@access cells Write() Whole()\n        Detangle.@access cell_of Write() Whole()\n        # Parallel binning builds per-cell particle lists.\n        bin_particles_auto!(cells, cell_of, posx, posy, box, n_cells_x, n_cells_y, bin_ctx)\n    end\n    for (bi, r) in enumerate(blocks)\n        Detangle.@spawn Detangle.@task \"forces-$bi\" begin\n            Detangle.@access posx Read() Whole()\n            Detangle.@access posy Read() Whole()\n            Detangle.@access cells Read() Whole()\n            Detangle.@access cell_of Read() Whole()\n            Detangle.@access neighbors Read() Whole()\n            Detangle.@access forcex Write() Block(r)\n            Detangle.@access forcey Write() Block(r)\n            accumulate_forces!(r, cell_of, neighbors, cells, posx, posy, forcex, forcey, box, cutoff2, soft, particle_radius, k_spring)\n        end\n        Detangle.@spawn Detangle.@task \"integrate-pos-$bi\" begin\n            Detangle.@access posx ReadWrite() Block(r)\n            Detangle.@access posy ReadWrite() Block(r)\n            Detangle.@access velx ReadWrite() Block(r)\n            Detangle.@access vely ReadWrite() Block(r)\n            Detangle.@access forcex Read() Block(r)\n            Detangle.@access forcey Read() Block(r)\n            integrate_position!(r, posx, posy, velx, vely, forcex, forcey, dt, box)\n        end\n    end\n    Detangle.@spawn Detangle.@task \"bin-2\" begin\n        Detangle.@access posx Read() Whole()\n        Detangle.@access posy Read() Whole()\n        Detangle.@access cells Write() Whole()\n        Detangle.@access cell_of Write() Whole()\n        bin_particles_auto!(cells, cell_of, posx, posy, box, n_cells_x, n_cells_y, bin_ctx)\n    end\n    for (bi, r) in enumerate(blocks)\n        Detangle.@spawn Detangle.@task \"forces2-$bi\" begin\n            Detangle.@access posx Read() Whole()\n            Detangle.@access posy Read() Whole()\n            Detangle.@access cells Read() Whole()\n            Detangle.@access cell_of Read() Whole()\n            Detangle.@access neighbors Read() Whole()\n            Detangle.@access forcex Write() Block(r)\n            Detangle.@access forcey Write() Block(r)\n            accumulate_forces!(r, cell_of, neighbors, cells, posx, posy, forcex, forcey, box, cutoff2, soft, particle_radius, k_spring)\n        end\n        Detangle.@spawn Detangle.@task \"integrate-vel-$bi\" begin\n            Detangle.@access velx ReadWrite() Block(r)\n            Detangle.@access vely ReadWrite() Block(r)\n            Detangle.@access forcex Read() Block(r)\n            Detangle.@access forcey Read() Block(r)\n            integrate_velocity!(r, velx, vely, forcex, forcey, dt)\n        end\n    end\nend\n\nprintln(\"tasks: \", length(dag.tasks))\n\nprintln(\"starting simulation...\")\nif save_frames\n    mkpath(output_dir)\n    for path in readdir(output_dir; join=true)\n        if occursin(r\"frame_\\\\d+\\\\.csv$\", path)\n            rm(path)\n        end\n    end\nend\nfor step in 1:steps\n    execute_threads!(dag)\n\n    if step % progress_stride == 0 || step == 1 || step == steps\n        println(\"step \", step, \"/\", steps)\n    end\n\n    if save_frames && (step % frame_stride == 0)\n        mkpath(output_dir)\n        path = joinpath(output_dir, \"frame_\" * lpad(string(step), 4, '0') * \".csv\")\n        write_frame_csv(path, posx, posy)\n    end\nend\n\nprintln(\"completed \", steps, \" steps with \", 4 * length(blocks) + 2, \" tasks/step\")\nprintln(\"frames written to \", output_dir)\ninclude(joinpath(@__DIR__, \"tools\", \"build_md_animation.jl\"))\n","category":"section"},{"location":"tutorials/generated/03_molecular_dynamics/#Visualization","page":"Molecular Dynamics","title":"Visualization","text":"Animation generated during docs build from MD frame CSVs.\n\n<iframe src=\"03_molecular_dynamics_animation.html\" width=\"720\" height=\"760\" style=\"border:1px solid #d0d7de;\"></iframe>\n\nOpen animation in a new tab","category":"section"},{"location":"tutorials/generated/04_histogram/#Histogram","page":"Histogram","title":"Histogram","text":"This page is auto-generated from examples/04_histogram.jl.\n\nThe tutorial code is rendered only (not executed during docs build).\n\nusing Detangle\nusing Base.Threads\n\n# Example: histogramming with reduction privatization.\n# Each task processes a block of data and reduces into shared bins.\n\nn = 2_500_000\nnbins = 20\nblock_size = 125_000\n\n# Gaussian-shaped data mapped into integer bins.\nmu = (nbins + 1) / 2\nsigma = nbins / 7\ndata = Vector{Int}(undef, n)\nfor i in 1:n\n    x = mu + sigma * randn()\n    bin = clamp(Int(round(x)), 1, nbins)\n    data[i] = bin\nend\nblocks = eachblock(n, block_size)\n# Extra work to make each update heavier without changing the bin.\n@inline function extra_work(x::Int, i::Int)\n    v = x + i\n    @inbounds for _ in 1:8\n        v = (v * 1664525 + 1013904223)\n    end\n    return v\nend\n\nhist = zeros(Int, nbins)\n\ndag = detangle_foreach(blocks) do r, bi\n    Detangle.@task \"hist-$bi\" begin\n        Detangle.@access hist Reduce(+) Whole()\n        @inbounds for i in r\n            bin = data[i]\n            extra_work(bin, i) # Adds compute without changing the bin, so parallelism has real work to speed up.\n            Detangle.reduce_add!(hist, +, Whole(), bin, 1) # Route Reduce(+) into privatized buffers when enabled.\n        end\n    end\nend\n\n# Serial baseline.\nexpected = zeros(Int, nbins)\n@inbounds for i in 1:n\n    bin = data[i]\n    extra_work(bin, i)\n    expected[bin] += 1\nend\n\nprintln(\"running serialize...\")\nt_warm = @elapsed execute!(dag; backend=:serial, reduce_strategy=:serialize)\nfill!(hist, 0)\nprintln(\"warm-up serial = \", t_warm, \"s\")\nt_serial = @elapsed execute!(dag; backend=:serial, reduce_strategy=:serialize)\nok_serial = hist == expected\nprintln(\"serialize ok = \", ok_serial, \" (\", t_serial, \"s)\")\n\nfill!(hist, 0)\nprintln(\"running privatize...\")\nt_warm_par = @elapsed execute!(dag; backend=:threads, reduce_strategy=:privatize)\nfill!(hist, 0)\nprintln(\"warm-up privatize = \", t_warm_par, \"s\")\nt_parallel = @elapsed execute!(dag; backend=:threads, reduce_strategy=:privatize)\nok_parallel = hist == expected\nprintln(\"privatize ok = \", ok_parallel, \" (\", t_parallel, \"s)\")\n\nprintln(\"threads = \", nthreads())\nif ok_serial && ok_parallel\n    if t_parallel > 0\n        speedup = t_serial / t_parallel\n        println(\"speedup = \", round(speedup; digits=2), \"x\")\n    end\nelse\n    println(\"results differ; check reduce_add! usage and Reduce annotations\")\nend\n\nif nthreads() == 1\n    println(\"note: set JULIA_NUM_THREADS>1 to see parallel speedups\")\nend\n\n# Simple ASCII bar chart for tangible output.\nfunction print_histogram(counts; width::Int=40)\n    maxc = maximum(counts)\n    maxc == 0 && (println(\"(empty)\"); return)\n    for (i, c) in enumerate(counts)\n        bar_len = Int(round(width * c / maxc))\n        bar = repeat(\"█\", bar_len)\n        println(lpad(string(i), 3), \" | \", bar, \" \", c)\n    end\nend\n\nprintln(\"\\nHistogram (privatize run):\")\nprint_histogram(hist)\n","category":"section"},{"location":"tutorials/generated/04_histogram/#Visualization","page":"Histogram","title":"Visualization","text":"Real terminal output from running the histogram tutorial:\n\n$ JULIA_NUM_THREADS=8 julia --project=. examples/04_histogram.jl\n\nrunning serialize...\nwarm-up serial = 0.527666718s\nserialize ok = true (0.119671321s)\nrunning privatize...\nwarm-up privatize = 0.362077473s\nprivatize ok = true (0.164923423s)\nthreads = 8\nspeedup = 0.73x\n\nHistogram (privatize run):\n  1 |  1965\n  2 |  4206\n  3 | █ 11413\n  4 | ███ 27011\n  5 | ██████ 55574\n  6 | ████████████ 102643\n  7 | ███████████████████ 164771\n  8 | ████████████████████████████ 238271\n  9 | ███████████████████████████████████ 303096\n 10 | ████████████████████████████████████████ 342077\n 11 | ████████████████████████████████████████ 342239\n 12 | ███████████████████████████████████ 301909\n 13 | ████████████████████████████ 237434\n 14 | ███████████████████ 165157\n 15 | ████████████ 101635\n 16 | ██████ 55512\n 17 | ███ 27097\n 18 | █ 11526\n 19 | █ 4454\n 20 |  2010","category":"section"},{"location":"manual/concepts/#Concepts-and-Semantics","page":"Concepts and Semantics","title":"Concepts and Semantics","text":"This page defines the core entities and rules Detangle uses to infer safe execution order.","category":"section"},{"location":"manual/concepts/#Core-entities","page":"Concepts and Semantics","title":"Core entities","text":"TaskSpec: one task's name, access list, and computation thunk.\nAccess: one declaration of (object, effect, region).\nDAG: all tasks plus inferred dependency edges.\n\nA useful way to read this is:\n\nTaskSpec says what to run.\nAccess says what that task touches.\nDAG says what must happen before what.","category":"section"},{"location":"manual/concepts/#Access-declaration-pattern","page":"Concepts and Semantics","title":"Access declaration pattern","text":"In task code, accesses are typically declared with:\n\n@access obj effect region for one access\n@accesses begin ... end for a batch of access tuples\n\nThe declarations should match what the task body actually touches.","category":"section"},{"location":"manual/concepts/#Effects","page":"Concepts and Semantics","title":"Effects","text":"Effects describe how a task interacts with data.\n\nRead(): task only reads.\nWrite(): task mutates/overwrites.\nReadWrite(): task reads and mutates.\nReduce(op): task contributes to a reduction using operator op.\n\nIn conflict analysis, write-like effects are the important boundary:\n\nRead is non-mutating.\nWrite, ReadWrite, and Reduce are treated as write-like by default.","category":"section"},{"location":"manual/concepts/#Regions","page":"Concepts and Semantics","title":"Regions","text":"Regions describe where an effect applies.\n\nWhole(): entire object.\nBlock(r): contiguous 1D range.\nTile(I, J): 2D rectangular slice.\nKey(k): one keyed partition.\nIndexSet(idxs): sparse explicit indices.\n\nGranularity matters: finer regions expose more parallelism when accesses do not overlap.","category":"section"},{"location":"manual/concepts/#Conflict-detection","page":"Concepts and Semantics","title":"Conflict detection","text":"Two accesses conflict when all three are true:\n\nSame object identity.\nOverlapping region.\nAt least one write-like effect.\n\nIf accesses conflict, Detangle inserts an ordering edge in the DAG.","category":"section"},{"location":"manual/concepts/#Common-pitfalls","page":"Concepts and Semantics","title":"Common pitfalls","text":"Under-declaring writes as reads: this can hide true dependencies.\nOverly broad regions (for example Whole() everywhere): this can serialize work unnecessarily.\nMismatching declared regions and actual indexing in the task body.\nAssuming IndexSet is fully precise: overlap checks are conservative for IndexSet pairs.","category":"section"},{"location":"manual/concepts/#Practical-examples","page":"Concepts and Semantics","title":"Practical examples","text":"","category":"section"},{"location":"manual/concepts/#No-conflict","page":"Concepts and Semantics","title":"No conflict","text":"Read(x, Block(1:50))\nWrite(x, Block(51:100))\n\nSame object, but disjoint blocks, so these can run concurrently.","category":"section"},{"location":"manual/concepts/#Conflict","page":"Concepts and Semantics","title":"Conflict","text":"Read(x, Block(1:50))\nWrite(x, Block(25:75))\n\nBlocks overlap, and one side writes, so ordering is required.","category":"section"},{"location":"manual/concepts/#Key-partitioned-updates","page":"Concepts and Semantics","title":"Key-partitioned updates","text":"Write(counts, Key(:A))\nWrite(counts, Key(:B))\n\nDifferent keys do not overlap, so these can run concurrently.","category":"section"},{"location":"manual/concepts/#Reduction-note","page":"Concepts and Semantics","title":"Reduction note","text":"Reduce(op) declares reduction intent. With the privatization strategy, reductions with compatible operators can run in parallel and merge safely afterward.\n\nSee API Reference for exact signatures and options.","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This page covers the minimum path to install Detangle, build a small DAG, and run it safely.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"import Pkg\nPkg.add(\"Detangle\")\n\nFor local development in this repository:\n\nimport Pkg\nPkg.develop(path=\".\")","category":"section"},{"location":"getting_started/#First-DAG","page":"Getting Started","title":"First DAG","text":"using Detangle\n\nobj = Ref(0)\n\ndag = Detangle.@dag begin\n    Detangle.@spawn Detangle.@task \"init\" begin\n        Detangle.@accesses begin\n            (obj, Write(), Whole())\n        end\n        obj[] = 1\n    end\n\n    Detangle.@spawn Detangle.@task \"bump\" begin\n        Detangle.@accesses begin\n            (obj, ReadWrite(), Whole())\n        end\n        obj[] += 1\n    end\n\n    Detangle.@spawn Detangle.@task \"read\" begin\n        Detangle.@accesses begin\n            (obj, Read(), Whole())\n        end\n        println(\"value = \", obj[])\n    end\nend\n\nprint_dag(dag)\nexecute_serial!(dag)\n\nExpected output includes value = 2.","category":"section"},{"location":"getting_started/#Then-Run-On-Threads","page":"Getting Started","title":"Then Run On Threads","text":"execute_threads!(dag)\n\nSet Julia thread count before startup, for example:\n\nJULIA_NUM_THREADS=8 julia","category":"section"},{"location":"getting_started/#Common-first-checks","page":"Getting Started","title":"Common first checks","text":"If behavior is unexpected, run execute_serial! first.\nUse print_dag(dag) to inspect inferred dependencies.\nVerify @access/@accesses declarations match what task code actually touches.","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Read Manual Overview for concepts and APIs.\nRun end-to-end scripts in examples/ via Tutorials.\nSee Comparison for when Detangle is the right fit.","category":"section"},{"location":"#Detangle.jl","page":"Home","title":"Detangle.jl","text":"Detangle.jl is a Julia runtime for safe parallel execution. You annotate task effects (Read, Write, ReadWrite, Reduce) over explicit regions (Whole, Block, Key, ...), and Detangle builds a dependency DAG that can run serially or on threads.","category":"section"},{"location":"#Start-Here","page":"Home","title":"Start Here","text":"Read Getting Started\nRun one tutorial from Tutorials\nUse the Manual for deeper semantics and API details","category":"section"},{"location":"#Why-Detangle","page":"Home","title":"Why Detangle","text":"You write task logic directly in Julia.\nAccess annotations make dependencies explicit and debuggable.\nThe same DAG can run with different execution backends.","category":"section"},{"location":"#Core-API-At-A-Glance","page":"Home","title":"Core API At A Glance","text":"Effects: Read, Write, ReadWrite, Reduce\nRegions: Whole, Block, Key, Tile, IndexSet\nDAG building: @dag, @spawn, @task, @access, @accesses\nExecution: execute!, execute_threads!, execute_serial!, execute_privatize!\nHelpers: eachblock, detangle_foreach, detangle_map, detangle_mapreduce","category":"section"},{"location":"#Navigation","page":"Home","title":"Navigation","text":"Getting Started\nManual\nTutorials\nComparison","category":"section"}]
}
